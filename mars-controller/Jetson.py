'''
ark9719
6/17/2016
'''

import threading
from CodeInput import ConcreteLEDInput
from CodeInput import ConcreteMotorInput
from CodeInput import ConcreteStreamInput
from Threads import InputThread
from Threads import StatisticsThread
import logging
import pyping
import csv
import time

import sys
import json


class Jetson(object):
    """
    Jetson controls input from the controller, and manages the data sent back from the
    arduino/mars
    """

    def __init__(self, arduino, config, mars, timestamp):
        self._arduino = arduino
        self._mars = mars
        self._timestamp = timestamp
        self._lastMotion = 'None yet'
        self._lastLED = 'None yet'
        self._lastStream = 'None yet'
        self._config = config
        self._header = False
        self._lastRead = 0.0
        #self._connected = self.connectionPing()




    def repeatInput(self):
        """
        Continuesly scans for controller input first identifying the type of command then checking validity
        before writing to the arduino and storing the last command.

        :return:
        """

        while True:
            #Prompt for input
            controlCode = raw_input("LED or Motion Control code: ")

            #Create a Motor or LED code object
            if controlCode[0] == 'M':
                myCodeInput = ConcreteMotorInput(controlCode)
            elif controlCode[0] == 'L':
                myCodeInput = ConcreteLEDInput(controlCode)
            elif controlCode[0] == 'S':
                myCodeInput = ConcreteStreamInput(controlCode)
            else:
                logging.info("Invalid leading character. L, M, or S")
                break

            #Check for validity
            if myCodeInput.valid():
                print(controlCode + " inputed succesfully (valid).")
                logging.info(controlCode + " inputed succesfully (valid).")
                myCodeInput.issue(self._arduino) #Write to Arduino

                #Store the last code
                if(myCodeInput._type == 'M'):
                    self._lastMotion = controlCode
                elif(myCodeInput._type == 'L'):
                    self._lastLED = controlCode
                elif(myCodeInput._type == 'S'):
                    self._lastStream = controlCode

            else:
                logging.info("Code is invalid.")


    def statisticsController(self):
        """
        The loop for gathering, displaying, and saving data.
        :return:
        """

        while True:

            logging.info("Generating Statistics...")
            self._mars.generateStatistics()#Perform a statistics read

            logging.info("Displaying Statistics...")
            print(self.displayStatistics(self._mars._statistics)) #Display human readable statistics

            logging.info("Saving statistics...")
            self.saveStats(self._mars._statistics) #added this to last line of displayStats for testing

            self._mars._integTime = time.time() #Set the integ time to the time of the last read for calculations

    def displayStatistics(self, data):
        """
        Takes the data created by Mars and prints it, human readable.
        :param data:
        :return:
        """
        return json.dumps(data) 


    def saveStats(self, data):
        """
        This is the method in control of saving data generated by Mars onto the harddisk.
        :param data:
        :return:
        """
        #If the header to the file isn't written, write it.
        if (not self._header ):
            fileName = 'output/' + self._timestamp + '/' + self._config.logging.logName + '_machine_log.csv'
            with open(fileName, 'a') as rawFile:
                rawWriter = csv.DictWriter(rawFile, data.keys())
                rawWriter.writeheader()
            self._header = True

        try:
            fileName = 'output/' + self._timestamp + '/' + self._config.logging.logName + '_machine_log.csv'
            with open(fileName, 'a') as rawFile:
                rawWriter = csv.DictWriter(rawFile, data.keys())
                rawWriter.writerow(data)

        except Exception as e:
            logging.info("unable to log data because: \r\n {}".format(e))

    def connectionMonitor(self):
        """
        This method is intended to monitor the connection with the controller.
        :return:
        """
        while True:
            time.sleep(1)
            if (not self.connectionPing()):
                self._connected = False
                logging.info("Connection broken")


    def connectionPing(self):
        """
        This method performs a simple ping to the controller.
        :return:
        """
        request = pyping.ping(self._config.communications.masterIP)
        return (request.ret_code == 0)




