'''
ark9719
6/17/2016
'''

from CodeInput import ConcreteLEDInput, ConcreteStreamInput, ConcreteMotorInput
from Watchdog import Watchdog
import logging
import csv
import time
import json
import subprocess


class Jetson(object):
    """
    Jetson controls input from the controller, and manages the data sent back from the
    arduino/mars
    """

    def __init__(self, arduino, config, mars, timestamp):
        self._arduino = arduino
        self._mars = mars
        self._timestamp = timestamp
        self._lastMotion = 'None yet'
        self._lastLED = 'None yet'
        self._lastStream = 'None yet'
        self._config = config
        self._header = False
        self.initCommands()
        self._watchdog = Watchdog(self)



    def repeatInput(self):
        """
        Continuesly scans for controller input first identifying the type of command then checking validity
        before writing to the arduino and storing the last command.

        :return:
        """

        while True:
            #Prompt for input
            controlCode = raw_input("LED or Motion Control code: ")

            #Create a Motor or LED code object
            if controlCode[0] == 'M':
                myCodeInput = ConcreteMotorInput(controlCode)
            elif controlCode[0] == 'L':
                myCodeInput = ConcreteLEDInput(controlCode)
            elif controlCode[0] == 'S':
                myCodeInput = ConcreteStreamInput(controlCode, self._config)
            elif controlCode.lower() in self._sysCommands:
                self._sysCommands[controlCode]()
                continue
            elif controlCode == 'forward':
                speed = raw_input("How fast?")
                self._arduino.write("M110" + speed)
                continue
            elif controlCode == 'backward':
                speed = raw_input("How fast?")
                self._arduino.write("M100" + speed)
                continue

            else:
                logging.info("Invalid control code.")
                continue



            #Check for validity
            if myCodeInput.valid():

                if myCodeInput._type == 'M':
                    myCodeInput.issue(self._arduino)                        #Issue the code
                    self._lastMotion = controlCode                          #Store it
                    print(controlCode + " inputed succesfully (valid).")
                    logging.info(controlCode + " inputed succesfully (valid).")

                elif myCodeInput._type == 'L':
                    myCodeInput.issue(self._arduino)
                    self._lastLED = controlCode
                    print(controlCode + " inputed succesfully (valid).")
                    logging.info(controlCode + " inputed succesfully (valid).")

                elif myCodeInput._type == 'S':
                    myCodeInput.issue(self._timestamp)
                    self._lastStream = controlCode
                    print(controlCode + " inputed succesfully (valid).")
                    logging.info(controlCode + " inputed succesfully (valid).")

            else:
                logging.info("Code is invalid.")


    def statisticsController(self):
        """
        The loop for gathering, displaying, and saving data.
        :return:
        """

        while True:

            logging.info("Generating Statistics...")
            self._mars.generateStatistics()#Perform a statistics read

            logging.info("Displaying Statistics...")
            print(self.displayStatistics(self._mars._statistics)) #Display human readable statistics

            logging.info("Saving statistics...")
            self.saveStats(self._mars._statistics) #added this to last line of displayStats for testing

            self._mars._integTime = time.time() #Set the integ time to the time of the last read for calculations

            #self._watchdog.sniffPower()
            #self._watchdog.sniffUltrasonicDistance()
            #self._watchdog.react()

    def displayStatistics(self, data):
        """
        Takes the data created by Mars and prints it, human readable.
        :param data:
        :return:
        """
        return json.dumps(data) 


    def saveStats(self, data):
        """
        This is the method in control of saving data generated by Mars onto the harddisk.
        :param data:
        :return:
        """
        #If the header to the file isn't written, write it.
        if (not self._header ):
            fileName = 'output/' + self._timestamp + '/' + self._config.logging.logName + '_machine_log.csv'
            with open(fileName, 'a') as rawFile:
                rawWriter = csv.DictWriter(rawFile, data.keys())
                rawWriter.writeheader()
            self._header = True

        try:
            fileName = 'output/' + self._timestamp + '/' + self._config.logging.logName + '_machine_log.csv'
            with open(fileName, 'a') as rawFile:
                rawWriter = csv.DictWriter(rawFile, data.keys())
                rawWriter.writerow(data)

        except Exception as e:
            logging.info("unable to log data because: \r\n {}".format(e))


    def system_restart(self):
        logging.info("initiating safe restart")
        logging.info("shutting down arduino")
        self._arduino.arduinoPowerOff()
        ### add functionality to cut power to motor controller
        logging.info("restarting this computer")
        logging.info("this connection will be lost")
        time.sleep(1)
        subprocess.call(['sudo reboot'], shell=True)


    def system_shutdown(self):
        logging.info("initiating safe shutdown")
        logging.info("shutting down arduino")
        self._arduino.arduinoPowerOff()
        ### add functionality to cut power to motor controller
        logging.info("shutting downn this computer")
        logging.info("this connection will be lost")
        time.sleep(1)
        subprocess.call(['sudo poweroff'], shell=True)

    def initCommands(self):
        self._sysCommands = {'sys-shutdown': self.system_shutdown,
                                'sys-restart': self.system_restart,
                                'a-poweron': self._arduino.arduinoPowerOn,
                                'a-poweroff': self._arduino.arduinoPowerOff,
                                'a-restart': self._arduino.arduino_reset,
                                'recall': self._mars.recall,
                                # 'break': system.break_all_circuits(), \
                                'stream': self.defaultStreamIssue,
                                'brake': self._arduino.brake}

    def defaultStreamIssue(self):
        ConcreteStreamInput('S04',self._config).issue(self._timestamp)



